{"version":3,"sources":["../../src/fields/slugField.ts"],"sourcesContent":["import type { CheckboxField, Field, FieldHook, TextField } from 'payload'\n\nimport type { SlugFieldConfig } from '../types.js'\nimport type { PluginContext } from '../utils/createPluginContext.js'\nimport { createPluginField } from '../utils/createPluginField.js'\nimport { getPluginPath } from '../utils/getPluginPath.js'\nimport { generateSlug, normalizeSlugOptions } from '../utils/slugify.js'\n\nexport const validateSlug =\n  (pluginContext: PluginContext): FieldHook =>\n  ({ data, req, siblingData, value }) => {\n    const { slugFieldConfig } = pluginContext.fieldConfigs\n\n    // If the slug is locked, return the existing value\n    if (!siblingData[slugFieldConfig.lockFieldName]) {\n      return value\n    }\n\n    const missingFields: string[] = []\n\n    // Collect values of the fields used for slug generation\n    const fields = slugFieldConfig.useFields.map((field) => {\n      const fieldValue = data?.[field] || null\n\n      if (!fieldValue) {\n        missingFields.push(field) // Track missing fields\n      }\n\n      return fieldValue\n    })\n\n    // If any required fields are missing, log and return the original value\n    if (missingFields.length > 0) {\n      req.payload.logger.warn(\n        `Missing fields for slug generation: ${missingFields.map((f) => f).join(', ')}`,\n      )\n      return value\n    }\n\n    // Generate the slug using slugify\n    const processedSlug = generateSlug(fields, pluginContext.slugifyOptions)\n    return processedSlug\n  }\n\nconst uniqueSlug =\n  (pluginContext: PluginContext): FieldHook =>\n  async ({ collection, data, req, value }) => {\n    const { slugFieldConfig } = pluginContext.fieldConfigs\n\n    // Try to get the ID of the current document\n    const currentDocId = req.routeParams?.id || data?.id // From URL params (usually for update) // From the data being passed (useful for beforeChange hooks)\n\n    let slug = value\n    let suffix = 1\n\n    // Skip if autoIncrementSlug is disabled or there's no collection or slug is empty\n    if (slugFieldConfig.autoIncrementSlug == false || !collection?.slug || !slug) {\n      return value\n    }\n\n    while (true) {\n      const conflictingDocs = await req.payload\n        .find({\n          collection: collection.slug,\n          where: {\n            slug: { equals: slug },\n          },\n        })\n        .then((result) => result.docs.filter((doc) => doc.id !== currentDocId))\n\n      if (conflictingDocs.length === 0) {\n        return slug // If unique, return the slug\n      }\n\n      // Append suffix and increment if conflicts exist\n      slug = `${value}-${suffix}`\n      suffix++\n    }\n  }\n\nexport const createSlugField = createPluginField<SlugFieldConfig, Field[]>(\n  ({ context, fieldConfig }): Field[] => {\n    const { autoIncrementSlug, useFields = ['title'] } = fieldConfig\n\n    const checkBoxField: CheckboxField = {\n      name: 'slugLock',\n      type: 'checkbox',\n      defaultValue: true,\n\n      admin: {\n        hidden: true,\n        position: 'sidebar',\n      },\n    }\n\n    const slugField: TextField = {\n      name: 'slug',\n      type: 'text',\n      admin: {\n        components: {\n          Field: {\n            clientProps: {\n              custom: {\n                autoIncrementSlug,\n                checkboxFieldPath: checkBoxField.name,\n                slugifyOptions: normalizeSlugOptions(context.slugifyOptions),\n                watchFields: useFields,\n              },\n            },\n            path: getPluginPath('client', '#SlugFieldClient'),\n          },\n        },\n        position: 'sidebar',\n      },\n      hooks: {\n        beforeChange: [uniqueSlug(context)],\n        beforeValidate: [validateSlug(context)],\n      },\n      index: true,\n      localized: true,\n      required: true,\n      unique: true,\n    }\n\n    return [slugField, checkBoxField]\n  },\n)\n"],"names":["createPluginField","getPluginPath","generateSlug","normalizeSlugOptions","validateSlug","pluginContext","data","req","siblingData","value","slugFieldConfig","fieldConfigs","lockFieldName","missingFields","fields","useFields","map","field","fieldValue","push","length","payload","logger","warn","f","join","processedSlug","slugifyOptions","uniqueSlug","collection","currentDocId","routeParams","id","slug","suffix","autoIncrementSlug","conflictingDocs","find","where","equals","then","result","docs","filter","doc","createSlugField","context","fieldConfig","checkBoxField","name","type","defaultValue","admin","hidden","position","slugField","components","Field","clientProps","custom","checkboxFieldPath","watchFields","path","hooks","beforeChange","beforeValidate","index","localized","required","unique"],"mappings":"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"}